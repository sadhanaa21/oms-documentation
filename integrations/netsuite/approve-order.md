# Approve Order

### **NetsuiteItemLineId Attribute:**&#x20;

The NetsuiteItemLineId is generated and associated with OMS order items during a specific synchronization step after the sales order has been created in Netsuite. This synchronization step is crucial for mapping and aligning the order line items in OMS with their corresponding line item IDs in Netsuite. Verification of the presence of the NetsuiteItemLineId order item attribute is necessary. If all items of an order possess the NetsuiteItemLineId, the NETSUITE\_ORDER\_EXPORTED order attribute will be created.

### **Handling RX Products:**&#x20;

If an order includes RX products (prescription), it should be transferred to facility 1818. This process involves utilizing the OMS API for updating order items' ship group, specifically the updateOrderItemShipGroup service. Once the order is successfully moved to facility 1818, an order attribute named RX\_PRODUCT\_VERIFIED will be created. Importantly, this attribute is also created directly for non-RX products without any additional updates.

An order is eligible for approval only if it possesses both the **NETSUITE\_ORDER\_EXPORTED** and **RX\_PRODUCT\_VERIFIED** attributes.

## **Implementation Flow:**

The approval process for eligible orders will be implemented by NiFi. This workflow is divided into four segments:

1. **Order Attribute creation for NetSuite Exported Orders**
2. **Order Attribute creation for Orders with RX Products**
3. **Order Attribute creation for Orders without RX Products**
4. **Approve Order**

To create OrderAttributes, a CSV file will be generated. The HC job will then use this file to generate or import the corresponding data. Afterward, eligible orders for the approval feed will be fetched, and the HC job will proceed to approve them.



<details>

<summary>NiFi Flow</summary>

#### **All process groups except, order attribute creation for Orders with RX Products :**&#x20;

* All process groups, except for Order Attribute creation for Orders with RX Products, share the same NiFi flow.
* The **ExecuteSQLRecord** processor is used to execute distinct SQL queries, generating CSV files based on the defined Avro schema for creating order attributes.
* The subsequent processor, **RouteOnAttribute**, checks whether the flow file contains any records.
* The filename is then updated to the required format using the **UpdateAttribute** processor.
* The final step involves transferring the file to the SFTP location using the **PutSFTP** processor.
* The stored files will be accessed via HC to create order attributes.

**Process group order attribute creation for Orders with RX Products :**&#x20;

* The **ExecuteSQLRecord** processor is utilized to execute a SQL query.
* The file is then split into individual JSON objects by the **SplitJSON** processor.
* The **SplitJSON** processor generates two significant attributes: `fragment.count` and `fragment.identifier`.
* These JSON objects serve as the request body for API calls.
* For each JSON object, a POST request is made to the specified API endpoint using the **InvokeHTTP** processor.
* The **RouteOnAttribute** processor is configured with two dynamic properties: Failure and Success. Any status code other than 200 is considered a failure.
* Two relations are established based on these properties:

**Success:**

* In the success relations, the subsequent processor is **Wait**, which stays waiting until it receives notification from the **Notify** processor.
* Following a **MergeRecord** processor which will merge all the incoming flow files, the default fields along with required values are added here.
* Updating the file name using the **UpdateAttribute** processor.
* The file is kept on SFTP using the **PutSFTP** processor.

**Failure:**

* In the case of Failure relations, the subsequent processor is **Wait**, which stays waiting until it receives notification from the **Notify** processor.
* The coordination between **Wait** and **Notify** is facilitated through the use of the DistributedMapCacheService controller service and utilities the `fragment.count` and `fragment.identifier` attributes.
* Following the **Wait**, the **UpdateRecord** processor is used to log the orderId and its corresponding response generated by the API call.
* Finally, all the failure flow files are merged and placed under a directory named "http\_error\_log" using the **PutSFTP** processor.

**Failure, Success, and Unmatched:**

* For the combined Failure, Success, and Unmatched relations, the next processor is **UpdateRecord**. This processor adds the response corresponding to the orderId in the flow file.
* Subsequently, the **MergeRecord** processor is utilized with the Merge Strategy set to Defragment, waiting until the `fragment.count` becomes equal.
* For all the failure and original relations from **MergeRecord**, there is a Notify processor, and for all merged relations, there are **UpdateAttribute** and **PutSFTP** processors, directing flow files under the directory named "http\_log."

</details>

### &#x20;<a href="#user-content-nifi-flow" id="user-content-nifi-flow"></a>
